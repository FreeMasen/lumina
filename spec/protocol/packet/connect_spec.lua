local Connect = require "lumina.protocol.packet.connect"
local FixedHeader = require "lumina.protocol.packet.fixed_header"
local PacketType = require "lumina.protocol.packet.packet_type"
local test_utils = require "spec.test_utils"

local function round_trip_encode(v)
    local source = test_utils.generate_source(assert(v:encode_packet()))
    local back = assert(Connect.decode_packet(source, v.fixed_header))
    assert.are.same(v, back)
end
describe("Connect", function()
    it("round trip encoding", function()
        local v = Connect.new("imAClient")
        round_trip_encode(v)
    end)
    it("builder works", function()
        local v = Connect.new("imAClient")
        v:set_clean_session(true)
        round_trip_encode(v)
        v:set_clean_session(false)
        round_trip_encode(v)
        v:set_client_id("otherClient")
        round_trip_encode(v)
        v:set_keep_alive(12)
        round_trip_encode(v)
        v:set_password("hunter2")
        round_trip_encode(v)
        v:set_password(nil)
        round_trip_encode(v)
        v:set_username("otherUser")
        round_trip_encode(v)
        v:set_username(nil)
        round_trip_encode(v)
        v:set_will("aTopic", "someBytes")
        round_trip_encode(v)
        v:set_will(nil)
        round_trip_encode(v)
        v:set_will_retain(true)
        round_trip_encode(v)
        v:set_will_retain(false)
        round_trip_encode(v)
        for i=0,3 do
            v:set_will_qos(i)
            round_trip_encode(v)
        end
        local n, err = v:set_will_qos(5)
        assert(n == nil and err, "expected error when setting will_qos > 3")
    end)
    it("decodes from string #f", function()
        local msg = string.char(0x10, 0x11, 0x00, 0x04)
            .."MQTT"
            ..string.char(0x04, 0x00, 0x00, 0x00, 0x00, 0x05)
            .."12345"
        local source = test_utils.generate_source(msg)
        local fh = assert(FixedHeader.decode(source))
        assert.are.same(fh.packet_type, PacketType.connect())
        local packet = assert(Connect.decode_packet(source, fh))
        assert.are.equal("MQTT", packet.protocol_name.value)
        assert.are.equal("12345", packet.payload.client_id)
        assert.are.equal(msg, fh:encode()..packet:encode_packet())
    end)
end)